{
  "hash": "7aba17e0d9fd6d2d858b3c5327878b08",
  "result": {
    "markdown": "---\ntitle: \"Adding context to maps made with ggplot2\"\ndescription: \"How to set the extent of a map based upon a single layer.\"\nauthor:\n  - name: Mike Mahoney\n    url: {}\ndate: \"2023-10-31\"\ncategories: [R, Tutorials, Spatial, geospatial data]\nimage: banner.jpg\nformat: \n  html:\n    toc: true\nengine: knitr\n---\n\n\nA colleague asked me today how they could best add a larger data set for context to a map of a (spatially) smaller data set, without the map expanding to incorporate the whole of the larger data set. I didn't have a great answer off the top of my head, so this blog post is here to record what we tried, and what wound up working for us!\n\nSay we've got some spatial data set that covers a broad area; for instance, the `nc` data set from sf that contains the counties of North Carolina:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(library(sf))\nlibrary(ggplot2)\nnc <- system.file(\"shape/nc.shp\", package = \"sf\") |> \n  read_sf()\n\nggplot(nc) + \n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nWe also need a comparatively smaller data set that we're interested in visualizing. For this blog, simulate some number of observations inside one of the more central counties:\n\n\n::: {.cell}\n\n```{.r .cell-code}\njohnston <- nc[which(nc$NAME == \"Johnston\"), ]\njohnston_obs <- st_sample(johnston, 500)\n\nggplot() + \n  geom_sf(data = johnston) + \n  geom_sf(data = johnston_obs, color = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nOur goal is to add a bit more context to this map by drawing the borders of surrounding counties. The challenge is that ggplot will, by default, expand our visualization to contain the largest layer that we add:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = nc) + \n  geom_sf(data = johnston_obs, color = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nWe could control this using `expansion()` inside of `scale_*_continuous()` functions, in order to restrict the range of our visualization:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = nc) + \n  geom_sf(data = johnston_obs, color = \"red\") + \n  scale_x_continuous(expand = expansion(c(-0.63, -0.29))) + \n  scale_y_continuous(expand = expansion(c(-0.5, -0.28)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nBut these `expansion()` calls are relative to the scale of our larger data set, which makes them a bit difficult to reason about. We aren't specifying our extents in terms of the data that we actually care about visualizing, we're forced to specify them relative to the larger context that we don't care as much about.\n\nWe could make this a bit easier by filtering our larger data set to only observations that are near (or in this case, touching) the area we're actually trying to visualize:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneighbors <- nc[st_touches(johnston, nc)[[1]], ]\nggplot() + \n  geom_sf(data = neighbors) + \n  geom_sf(data = johnston_obs, color = \"red\") + \n  scale_x_continuous(expand = expansion(c(-0.3, -0.25))) + \n  scale_y_continuous(expand = expansion(c(-0.4, -0.25)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nBut while this _reduces_ the problem, moving the center of the larger layer closer to the center of the layer we care about, it still has the same issue as when we used the entire `nc` object.\n\nSo what we wound up doing was embracing a little bit of jank and reaching into the ggplot2 internals. We started off by making a \"base plot\" object that was zoomed out to the level of detail that we wanted:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- ggplot(johnston_obs) + \n  geom_sf() + \n  scale_x_continuous(expand = expansion(0.1)) + \n  scale_y_continuous(expand = expansion(0.1))\n\nbase_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nDefining our boundaries here is a bit easier to reason about -- the `expansion()` calls are centered on our data of interest and are expanding the scales relative to this focal data set. Once we've got our level of zoom where we want it, we can build our plot using `ggplot_build()` and then extract the ranges of our x and y scales from the constructed plot object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_plot <- ggplot_build(base_plot)\nxlim <- base_plot$layout$panel_params[[1]]$x_range\nylim <- base_plot$layout$panel_params[[1]]$y_range\n```\n:::\n\n\nWe can then use those ranges as limits, to force our final plot to have the same level of zoom as our simple map. That means we can add whatever layers we want to add context to our map, and not need to worry about fiddling with our scales in term of the largest layer we've added:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() + \n  geom_sf(data = nc) + \n  geom_sf(data = johnston_obs, color = \"red\") + \n  scale_x_continuous(limits = xlim) + \n  scale_y_continuous(limits = ylim)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nI have no idea how stable this approach will be -- [we're decidedly not playing on the same team as ggplot2](https://www.tidyverse.org/blog/2022/09/playing-on-the-same-team-as-your-dependecy/) with this approach -- but it works as of ggplot version 3.4.3, and it's made making maps a bit easier for us at the moment!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}