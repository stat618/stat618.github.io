{
  "hash": "42b4215721831fabf6f6edfd653b3a43",
  "result": {
    "markdown": "---\ntitle: \"Three fun R functions\"\ndescription: \"All the cool kids were jumping off the bridge!\"\nauthor:\n  - name: Mike Mahoney\n    url: {}\ndate: \"2023-10-24\"\ncategories: [R, Tutorials]\nimage: banner.jpg\nformat: \n  html:\n    toc: true\nengine: knitr\n---\n\n\nInspired by [Maëlle](https://masalmon.eu/2023/10/20/three-neat-functions/) who was inspired by [Yihui](https://yihui.org/en/2023/10/three-functions/) who was inspired by [Maëlle](https://masalmon.eu/2023/09/29/three-functions/)(who has [a whole](https://masalmon.eu/2023/08/31/three-shorten/) [series](https://masalmon.eu/2023/06/06/basic-patterns/) [about](https://masalmon.eu/2023/08/30/three-r-functions/) [this](https://masalmon.eu/2023/07/24/basic-notions/)), I wanted to share three useful base R functions that I think maybe don't get enough love. And inspired by [Maëlle again](https://masalmon.eu/2023/10/20/three-neat-functions/), my list here is actually four functions.\n\n## `sweep()`\n\nIf you ever need to do math with matrices, then `sweep()` is going to be your best friend. Say for instance we want to center and scale each column in a matrix. This is a pretty straightforward operation -- we need to calculate the mean and standard deviations for each column, subtract the column mean from each observation, and then divide those by the corresponding standard deviation.\n\nWe can use `apply` to get our means and standard deviations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate some fake data in a 10x10 matrix:\nx <- matrix(data = rnorm(100), nrow = 10)\n# Calculate one mean and sd for each column of our matrix:\ncol_means <- apply(x, 2, mean)\ncol_sds <- apply(x, 2, sd)\n```\n:::\n\n\nThe subtraction and division are a bit less straightforward. R's base math operators will attempt to do element-wise operations, treating our vector as a one-column array and replicating as needed. That's not what we want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(\n  (x - col_means) / col_sds,\n  scale(x)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Attributes: < Length mismatch: comparison on first 1 components >\"\n[2] \"Mean relative difference: 0.360556\"                               \n```\n:::\n:::\n\n\nWe could replicate our vector ourself, in order to take advantage of these element-wise operations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(\n  ((x - matrix(rep(col_means, 10), 10, byrow = TRUE)) / \n    matrix(rep(col_sds, 10), 10, byrow = TRUE)) |> as.vector(),\n  scale(x) |> as.vector()\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nBut that's silly, especially if we were working with more observations.\n\nBetter instead is to use `sweep()` to perform some operation between each element of our vector and each column of the matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Take every value in our matrix, and subtract its corresponding column mean:\ncentered <- sweep(\n  x = x, \n  MARGIN = 2, # just like in apply()\n  STATS = col_means, \n  FUN = \"-\" # \"-\" is the default argument -- we don't NEED to provide it here\n)\n```\n:::\n\n\nAnd we can similarly use `sweep()` to divide each column by its corresponding standard deviation, finishing up our centering and scaling:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Divide each value by its corresponding column sd:\ncentered_and_scaled <- sweep(centered, 2, col_sds, \"/\")\n\n# Works out identically to the built-in scale function:\nall.equal(\n  as.vector(centered_and_scaled),\n  as.vector(scale(x))\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThis is the main way I use `sweep()`, but there's no requirement you use it for math -- it works just as well with non-mathematical functions or non-numeric matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletter_mat <- matrix(rep(letters[1:5], 5), 5)\nletter_mat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"a\"  \"a\"  \"a\"  \"a\"  \"a\" \n[2,] \"b\"  \"b\"  \"b\"  \"b\"  \"b\" \n[3,] \"c\"  \"c\"  \"c\"  \"c\"  \"c\" \n[4,] \"d\"  \"d\"  \"d\"  \"d\"  \"d\" \n[5,] \"e\"  \"e\"  \"e\"  \"e\"  \"e\" \n```\n:::\n\n```{.r .cell-code}\nsweep(letter_mat, 2, LETTERS[1:5], paste0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"aA\" \"bA\" \"cA\" \"dA\" \"eA\" \"aB\" \"bB\" \"cB\" \"dB\" \"eB\" \"aC\" \"bC\" \"cC\" \"dC\" \"eC\"\n[16] \"aD\" \"bD\" \"cD\" \"dD\" \"eD\" \"aE\" \"bE\" \"cE\" \"dE\" \"eE\"\n```\n:::\n:::\n\n\n## `reformulate()` and `DF2formula()`\n\nThe `reformulate()` function is a lifesaver if you're trying to write long or complicated formulas, or multiple formulas generated by some other logic in your code.\n\nThe function is pretty straightforward. If you're trying to make a formula `y ~ x + z`, provide your predictors as the first argument and your outcome as the second:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreformulate(c(\"x\", \"z\"), \"y\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ny ~ x + z\n```\n:::\n:::\n\n\nThe nice thing is that `reformulate` accepts vectors as inputs, making it easy to construct a vector of predictors and automatically turn them into a formula:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreformulate(letters, \"outcome\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\noutcome ~ a + b + c + d + e + f + g + h + i + j + k + l + m + \n    n + o + p + q + r + s + t + u + v + w + x + y + z\n```\n:::\n\n```{.r .cell-code}\nreformulate(names(Orange), \"age\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nage ~ Tree + age + circumference\n```\n:::\n:::\n\n\nAnd in particular, this is an excellent alternative to dropping a few columns in order to use `outcome ~ .` -- instead, you can use `setdiff()` to exclude those columns from your formula:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutcome_variable <- \"age\"\nreformulate(setdiff(names(Orange), outcome_variable), outcome_variable)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nage ~ Tree + circumference\n```\n:::\n:::\n\n\nRelatedly, the function `DF2formula()` will automatically turn the column names from a data frame into a formula. The first column will become the outcome variable, and the rest will be used as predictors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDF2formula(Orange)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTree ~ age + circumference\n```\n:::\n:::\n\n\nTo change what column is used as the outcome variable, reorder the columns in your data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDF2formula(Orange[3:1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncircumference ~ age + Tree\n```\n:::\n:::\n\n\n## `str2lang()`\n\nShockingly enough, `str2lang()` function turns a string into a language object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrowth_rate <- \"circumference / age\"\nstr2lang(growth_rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncircumference/age\n```\n:::\n\n```{.r .cell-code}\nclass(str2lang(growth_rate))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"call\"\n```\n:::\n:::\n\n\nWooooo!\n\nI think that, to most people, this does not sound immediately useful.^[I think, to most people, this barely sounds like English.] But the idea that your code can turn plain text into code at runtime is pretty powerful, and some of the most R-esque nonsense that R has to offer.\n\nFor instance, we can use `eval()` to actually execute the call created by `str2lang()` in our global environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\neval(str2lang(\"2 + 2\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nAnd that string can do anything that regular R code can do -- assign variables, manage connections, any procedure that normal R code can do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\neval(str2lang(\"x <- 3\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nWe can also use this with `with()` or `local()` to execute our code inside of other environments. For instance, if we want to calculate our `growth_rate` from earlier, we can run that code with the `Orange` data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(Orange, eval(str2lang(growth_rate)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.25423729 0.11983471 0.13102410 0.11454183 0.09748172 0.10349854\n [7] 0.09165613 0.27966102 0.14256198 0.16716867 0.15537849 0.13972380\n[13] 0.14795918 0.12831858 0.25423729 0.10537190 0.11295181 0.10756972\n[19] 0.09341998 0.10131195 0.08849558 0.27118644 0.12809917 0.16867470\n[25] 0.16633466 0.14541024 0.15233236 0.13527181 0.25423729 0.10123967\n[31] 0.12198795 0.12450199 0.11535337 0.12682216 0.11188369\n```\n:::\n:::\n\n\nThis can be a powerful way to \"import\" code from other sources, for instance if you have a CSV of equations you want to run against a data frame. You want to be careful when using this with untrusted inputs, of course -- if your input includes a call to `system()`, it might wind up wrecking your computer! \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}