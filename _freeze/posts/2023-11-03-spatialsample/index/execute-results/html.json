{
  "hash": "65e2b2df7d16a713901752e56ef296b5",
  "result": {
    "markdown": "---\ntitle: \"spatialsample 0.5.0 is now on CRAN\"\ndescription: \"Bug fixes and reexports, oh my\"\nauthor:\n  - name: Mike Mahoney\n    url: {}\ndate: \"2023-11-03\"\ncategories: [R, Spatial, geospatial data, spatialsample, R packages]\nimage: banner.jpg\nformat: \n  html:\n    toc: true\nengine: knitr\n---\n\n\nThe [newest version of spatialsample](https://github.com/tidymodels/spatialsample), the tidymodels package I maintain for spatial cross-validation, just landed on CRAN, with binaries for Windows and Mac coming in the next few days. \n\nThis release mostly fixes a few bugs in `spatial_block_cv()` and `spatial_nndm_cv()`. The only new feature is that `get_rsplit()` is now reexported from rsample, providing a nicer interface for extracting individual `rsplit` objects from an `rset`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spatialsample)\n\nfolds <- spatial_clustering_cv(boston_canopy, 2)\n\nall.equal(\n  get_rsplit(folds, 1),\n  folds$splits[[1]]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nMore pressing are two sets of breaking changes. The first of these is that `spatial_block_cv()` now creates slightly different grids, covering a very slightly larger area, which may change what fold any given observation is assigned into. This is to address a problem [reported on StackOverflow](https://stackoverflow.com/q/77374348/9625040) where, if data fell exactly on grid lines (which was somewhat common with regularly-spaced grids of data), it would be assigned to both of the polygons on either side of the line.\n\nThe amount of grid expansion performed can be controlled using the new `expand_bbox` argument to `spatial_block_cv()`. If observations are still assigned to multiple folds, the function will now throw an error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndrought_sf <- sf::st_as_sf(\n  expand.grid(\n    x = seq(995494, 1018714, 430),\n    y = seq(1019422, by = 430, length.out = 55)\n  ),\n  coords = c(\"x\", \"y\"),\n  crs = 7760\n)\n\ntry(spatial_block_cv(drought_sf, expand_bbox = 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nError in generate_folds_from_blocks(data, centroids, grid_blocks, v, n,  : \n  Some observations fell exactly on block boundaries, meaning they were assigned to multiple assessment sets unexpectedly.\nâ„¹ Try setting a different `expand_bbox` value, an `offset`, or use a different number of folds.\n```\n:::\n:::\n\n\nBut hopefully the expansion will make this error relatively uncommon:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfolds <- spatial_block_cv(drought_sf)\n\nautoplot(folds)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThis is a breaking change for data in projected coordinate reference systems. Data in geographic coordinates was actually already using these slightly larger grids, [due to issues with straight-line grids in non-planar CRS](https://github.com/ropensci/stplanr/pull/467), so this change just makes the amount of grid expansion controllable there.\n\nThe other breaking change/bug-fix is in `spatial_nndm_cv()`. The `prediction_sites` argument to `spatial_nndm_cv()` lets you specify the actual sites you were going to generate predictions at. In older versions of spatialsample, if any of the data in `prediction_sites` weren't points, then this function would instead randomly sample points from inside the bounding box of the entire `prediction_sites` object.\n\nStarting with spatialsample 0.5.0, passing a single polygon to `prediction_sites` will cause `spatial_nndm_cv()` to instead sample points from inside that polygon, allowing you fine-grained control over the boundaries for this sampling stage. This feels like a more intuitive interface, and you can always revert to previous behaviors by passing `sf::st_as_sf(sf::st_as_sfc(sf::st_bbox(prediction_sites)))` if you'd rather sample from the bounding box instead.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}